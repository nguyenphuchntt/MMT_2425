####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import json
import copy

#NOTE: Thuật toán Distance Vector
# Mỗi router chứa một bảng dv chứa distance (cost) giữa nó và các router khác

# Các bước hoạt động:
# Mỗi router truyền bảng dv của nó sang tất cả các router kết nối trực tiếp với nó thông qua packet (routing packet).
# Mỗi router khi nhận được bảng dv từ "hàng xóm", router sẽ tính lại distance khi:
#   dv đó chứa thông tin khác so với dv mà router đang lưu
#   distancce tới "hàng xóm" đã giảm
# Việc tính toán dựa trên tính min(d(x, y); d(x, v) + d(v, y))


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.infinity = 16 # Cost đại diện cho không gửi được 
        
        # dict chứa thông tin về neighbors: port, addr, link_cost
        self.ports_to_neighbors = {}
        
        # dict chứa thông tin về tất cả các router khác và cost 
        self.dv = {
            self.addr: {'cost': 0, 'next_addr': self.addr, 'port': None}
        }
        
        # dict lưu vector khoảng cách nhất nhận được từ mỗi neighbor 
        # dict(dict(
        # "neighbor_addr": {'A': 1, 'B': 2}
        # )) -> ví dụ
        self.neighbor_dv = {}
        
        # dict lưu port vs addr
        self.forwarding_table = {self.addr: None}
        

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute: # Nếu là gói dữ liệu
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr == self.addr: # Nếu đích là router hiện tại -> không cần xét nữa
                return 
            
            if packet.dst_addr in self.forwoarding_table and self.forwoarding_table[packet.dst_addr] is not None: # Nếu dst_addr có trong forwarding table -> gửi nó đi theo port trong forwarding table
                output_port = self.forwoarding_table[packet.dst_addr]
                self.send(output_port, packet)
                
        else: # Nếu là gói tin router packet 
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            receive_dv = json.loads(packet.content)
            
            src_addr = packet.src_addr
            
            # Kiểm tra xem router gửi gói tin có nằm trong keys của self.neighbor_dv khônng
            # Nếu đã có rồi thì kiểm tra tiếp xem nội dung có khác không 
            # Nếu khác thì tiến hành cập nhật qua hàm update_dv()
            if src_addr not in self.neighbor_dv or self.neighbor_dv[src_addr] != receive_dv:
                self.neighbor_dv[src_addr] = receive_dv
                self.update_dv()
            

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            pass
        
    def update_dv(self):
        
        current_dv = copy.deepcopy(self.dv)
        new_dv = {self.addr: {'cost': 0, 'next_hop_addr': self.addr, 'port': None}}
        
        dest_addrs = set()
        dest_addrs.update(current_dv.keys()) # Lấy được tất cả các addr của router khác là key của self.dv
        
        for neighbor_info in self.ports_to_neighbors.values(): # Lấy addr của chính các neighbors
            dest_addrs.add(neighbor_info['neighbor_addr'])
        
        for neighbor_dv in self.neighbor_distance_vectors.values():
            dest_addrs.update(neighbor_dv.keys()) # Lấy được tất cả các addr của router khác là có liên kết với neighbors
        
        for dest_addr in dest_addrs:
            if dest_addr == self.addr: # Nếu là router hiện tại thì không cần xét
                continue
        
            # Khởi tạo
            min_cost = self.infinity
            min_cost_addr = None
            min_cost_port = None

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"
